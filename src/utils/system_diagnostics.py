"""
ÏãúÏä§ÌÖú ÏßÑÎã® Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÎèÑÍµ¨

Ïù¥ Î™®ÎìàÏùÄ DAEBAK_AI ÏãúÏä§ÌÖúÏùò Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏÉÅÌÉúÎ•º ÏßÑÎã®ÌïòÍ≥† Î™®ÎãàÌÑ∞ÎßÅÌï©ÎãàÎã§.
ÏÑ±Îä• Î¨∏Ï†ú, Íµ¨ÏÑ± Ïò§Î•ò, ÏùòÏ°¥ÏÑ± Î¨∏Ï†ú Îì±ÏùÑ ÏûêÎèôÏúºÎ°ú Í∞êÏßÄÌï©ÎãàÎã§.
"""

# 1. ÌëúÏ§Ä ÎùºÏù¥Î∏åÎü¨Î¶¨
import os
import sys
import json
import time
import importlib
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime
import traceback

# 2. ÏÑúÎìúÌååÌã∞
import numpy as np
import pandas as pd
import psutil

# 3. ÌîÑÎ°úÏ†ùÌä∏ ÎÇ¥Î∂Ä
from .unified_logging import get_logger
from .config_loader import load_config

logger = get_logger(__name__)


class SystemDiagnostics:
    """
    ÏãúÏä§ÌÖú ÏßÑÎã® ÌÅ¥ÎûòÏä§

    Ï†ÑÏ≤¥ ÏãúÏä§ÌÖúÏùò ÏÉÅÌÉúÎ•º Ï≤¥ÌÅ¨ÌïòÍ≥† Î¨∏Ï†úÏ†êÏùÑ ÏßÑÎã®Ìï©ÎãàÎã§.
    """

    def __init__(self, config_path: Optional[str] = None):
        """
        ÏãúÏä§ÌÖú ÏßÑÎã®Í∏∞ Ï¥àÍ∏∞Ìôî

        Args:
            config_path: ÏÑ§Ï†ï ÌååÏùº Í≤ΩÎ°ú
        """
        self.config_path = config_path or "config/config.yaml"
        self.config = None
        self.logger = get_logger(__name__)

        # ÏßÑÎã® Í≤∞Í≥º Ï†ÄÏû•
        self.diagnostic_results = {}
        self.health_status = "unknown"

        self.logger.info("ÏãúÏä§ÌÖú ÏßÑÎã®Í∏∞ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    def run_full_diagnostics(self) -> Dict[str, Any]:
        """
        Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú ÏßÑÎã® Ïã§Ìñâ

        Returns:
            ÏßÑÎã® Í≤∞Í≥º
        """
        self.logger.info("üîç Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú ÏßÑÎã® ÏãúÏûë")
        start_time = time.time()

        diagnostic_results = {
            "timestamp": datetime.now().isoformat(),
            "diagnostics": {},
        }

        # Í∞Å ÏßÑÎã® Ìï≠Î™© Ïã§Ìñâ
        diagnostics = [
            ("environment", self._check_environment),
            ("dependencies", self._check_dependencies),
            ("configuration", self._check_configuration),
            ("file_structure", self._check_file_structure),
            ("model_availability", self._check_model_availability),
            ("data_integrity", self._check_data_integrity),
            ("performance", self._check_performance),
            ("memory_usage", self._check_memory_usage),
            ("disk_space", self._check_disk_space),
            ("import_health", self._check_import_health),
        ]

        for diagnostic_name, diagnostic_func in diagnostics:
            try:
                self.logger.info(f"ÏßÑÎã® Ï§ë: {diagnostic_name}")
                result = diagnostic_func()
                diagnostic_results["diagnostics"][diagnostic_name] = result

            except Exception as e:
                self.logger.error(f"{diagnostic_name} ÏßÑÎã® Ïã§Ìå®: {e}")
                diagnostic_results["diagnostics"][diagnostic_name] = {
                    "status": "error",
                    "error": str(e),
                    "traceback": traceback.format_exc(),
                }

        # Ï†ÑÏ≤¥ Í±¥Í∞ï ÏÉÅÌÉú ÌèâÍ∞Ä
        overall_health = self._assess_overall_health(diagnostic_results["diagnostics"])
        diagnostic_results["overall_health"] = overall_health

        # Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
        recommendations = self._generate_recommendations(
            diagnostic_results["diagnostics"]
        )
        diagnostic_results["recommendations"] = recommendations

        # Ïã§Ìñâ ÏãúÍ∞Ñ
        diagnostic_results["execution_time"] = time.time() - start_time

        self.diagnostic_results = diagnostic_results
        self.health_status = overall_health["status"]

        self.logger.info(f"‚úÖ ÏãúÏä§ÌÖú ÏßÑÎã® ÏôÑÎ£å: {overall_health['status']}")
        return diagnostic_results

    def _check_environment(self) -> Dict[str, Any]:
        """ÌôòÍ≤Ω ÏÑ§Ï†ï Ï≤¥ÌÅ¨"""
        try:
            python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"

            # ÌïÑÏöîÌïú ÌôòÍ≤Ω Î≥ÄÏàò Ï≤¥ÌÅ¨
            required_env_vars = ["PYTHONPATH"]

            env_status = {}
            for var in required_env_vars:
                env_status[var] = {
                    "exists": var in os.environ,
                    "value": os.environ.get(var, "Not set"),
                }

            return {
                "status": "ok",
                "python_version": python_version,
                "platform": sys.platform,
                "environment_variables": env_status,
                "working_directory": os.getcwd(),
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_dependencies(self) -> Dict[str, Any]:
        """ÏùòÏ°¥ÏÑ± Ìå®ÌÇ§ÏßÄ Ï≤¥ÌÅ¨"""
        try:
            required_packages = [
                "numpy",
                "pandas",
                "scikit-learn",
                "torch",
                "lightgbm",
                "xgboost",
                "catboost",
                "scipy",
                "psutil",
                "pyyaml",
            ]

            package_status = {}
            missing_packages = []

            for package in required_packages:
                try:
                    module = importlib.import_module(package)
                    version = getattr(module, "__version__", "unknown")
                    package_status[package] = {"available": True, "version": version}
                except ImportError:
                    package_status[package] = {"available": False, "version": None}
                    missing_packages.append(package)

            status = "ok" if not missing_packages else "warning"

            return {
                "status": status,
                "packages": package_status,
                "missing_packages": missing_packages,
                "total_checked": len(required_packages),
                "available_count": len(required_packages) - len(missing_packages),
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_configuration(self) -> Dict[str, Any]:
        """ÏÑ§Ï†ï ÌååÏùº Ï≤¥ÌÅ¨"""
        try:
            config_checks = {
                "config_file_exists": os.path.exists(self.config_path),
                "config_readable": False,
                "required_sections": [],
                "missing_sections": [],
            }

            if config_checks["config_file_exists"]:
                try:
                    self.config = load_config(self.config_path)
                    config_checks["config_readable"] = True

                    # ÌïÑÏàò ÏÑπÏÖò Ï≤¥ÌÅ¨
                    required_sections = ["data", "models", "training", "evaluation"]

                    for section in required_sections:
                        if hasattr(self.config, section) or (
                            isinstance(self.config, dict) and section in self.config
                        ):
                            config_checks["required_sections"].append(section)
                        else:
                            config_checks["missing_sections"].append(section)

                except Exception as e:
                    config_checks["config_error"] = str(e)

            status = "ok"
            if not config_checks["config_file_exists"]:
                status = "error"
            elif not config_checks["config_readable"]:
                status = "error"
            elif config_checks["missing_sections"]:
                status = "warning"

            return {
                "status": status,
                "config_path": self.config_path,
                "checks": config_checks,
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_file_structure(self) -> Dict[str, Any]:
        """ÌååÏùº Íµ¨Ï°∞ Ï≤¥ÌÅ¨"""
        try:
            required_directories = [
                "src/analysis",
                "src/models/ml",
                "src/models/dl",
                "src/models/meta",
                "src/core",
                "src/evaluation",
                "src/pipeline",
                "src/utils",
                "config",
                "data",
                "savedModels",
            ]

            directory_status = {}
            missing_directories = []

            for directory in required_directories:
                exists = os.path.exists(directory)
                directory_status[directory] = {
                    "exists": exists,
                    "is_directory": os.path.isdir(directory) if exists else False,
                }

                if not exists:
                    missing_directories.append(directory)

            # Ï§ëÏöî ÌååÏùº Ï≤¥ÌÅ¨
            important_files = [
                "src/core/recommendation_engine.py",
                "src/evaluation/backtester.py",
                "src/evaluation/diversity_evaluator.py",
                "src/models/meta/meta_learner_model.py",
            ]

            file_status = {}
            missing_files = []

            for file_path in important_files:
                exists = os.path.exists(file_path)
                file_status[file_path] = {
                    "exists": exists,
                    "size": os.path.getsize(file_path) if exists else 0,
                }

                if not exists:
                    missing_files.append(file_path)

            status = "ok"
            if missing_directories or missing_files:
                status = (
                    "warning"
                    if len(missing_directories) + len(missing_files) < 3
                    else "error"
                )

            return {
                "status": status,
                "directories": directory_status,
                "files": file_status,
                "missing_directories": missing_directories,
                "missing_files": missing_files,
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_model_availability(self) -> Dict[str, Any]:
        """Î™®Îç∏ Í∞ÄÏö©ÏÑ± Ï≤¥ÌÅ¨"""
        try:
            model_files = [
                "savedModels/lightgbm_model.pkl",
                "savedModels/autoencoder_model.pt",
                "savedModels/tcn_model.pt",
                "savedModels/random_forest_model.pkl",
            ]

            model_status = {}
            available_models = []
            missing_models = []

            for model_file in model_files:
                exists = os.path.exists(model_file)
                model_status[model_file] = {
                    "exists": exists,
                    "size_mb": (
                        os.path.getsize(model_file) / 1024 / 1024 if exists else 0
                    ),
                    "last_modified": (
                        datetime.fromtimestamp(os.path.getmtime(model_file)).isoformat()
                        if exists
                        else None
                    ),
                }

                if exists:
                    available_models.append(model_file)
                else:
                    missing_models.append(model_file)

            status = "ok" if len(available_models) >= 2 else "warning"
            if not available_models:
                status = "error"

            return {
                "status": status,
                "models": model_status,
                "available_models": available_models,
                "missing_models": missing_models,
                "availability_ratio": len(available_models) / len(model_files),
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_data_integrity(self) -> Dict[str, Any]:
        """Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Ï≤¥ÌÅ¨"""
        try:
            data_files = [
                "data/cache/feature_vectors_full.npy",
                "data/lottery_data.csv",
            ]

            data_status = {}
            valid_files = []
            corrupted_files = []

            for data_file in data_files:
                if os.path.exists(data_file):
                    try:
                        # ÌååÏùº ÌòïÏãùÏóê Îî∞Î•∏ Í≤ÄÏ¶ù
                        if data_file.endswith(".npy"):
                            data = np.load(data_file)
                            data_status[data_file] = {
                                "exists": True,
                                "valid": True,
                                "shape": data.shape,
                                "dtype": str(data.dtype),
                                "size_mb": os.path.getsize(data_file) / 1024 / 1024,
                            }
                        elif data_file.endswith(".csv"):
                            data = pd.read_csv(data_file, nrows=5)  # ÏùºÎ∂ÄÎßå ÏùΩÏñ¥ÏÑú Í≤ÄÏ¶ù
                            data_status[data_file] = {
                                "exists": True,
                                "valid": True,
                                "columns": len(data.columns),
                                "sample_rows": len(data),
                                "size_mb": os.path.getsize(data_file) / 1024 / 1024,
                            }

                        valid_files.append(data_file)

                    except Exception as e:
                        data_status[data_file] = {
                            "exists": True,
                            "valid": False,
                            "error": str(e),
                        }
                        corrupted_files.append(data_file)
                else:
                    data_status[data_file] = {"exists": False, "valid": False}

            status = "ok" if len(valid_files) > 0 and not corrupted_files else "warning"

            return {
                "status": status,
                "data_files": data_status,
                "valid_files": valid_files,
                "corrupted_files": corrupted_files,
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_performance(self) -> Dict[str, Any]:
        """ÏÑ±Îä• Ï≤¥ÌÅ¨"""
        try:
            # CPU ÏÑ±Îä• ÌÖåÏä§Ìä∏
            start_time = time.time()
            test_array = np.random.rand(1000, 1000)
            np.dot(test_array, test_array.T)
            cpu_test_time = time.time() - start_time

            # Î©îÎ™®Î¶¨ ÏÑ±Îä• ÌÖåÏä§Ìä∏
            start_time = time.time()
            large_array = np.random.rand(5000, 1000)
            del large_array
            memory_test_time = time.time() - start_time

            # ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()

            performance_metrics = {
                "cpu_test_time": cpu_test_time,
                "memory_test_time": memory_test_time,
                "cpu_usage_percent": cpu_percent,
                "memory_usage_percent": memory.percent,
                "available_memory_gb": memory.available / 1024 / 1024 / 1024,
                "cpu_count": psutil.cpu_count(),
            }

            # ÏÑ±Îä• ÏÉÅÌÉú ÌèâÍ∞Ä
            status = "ok"
            if cpu_percent > 80 or memory.percent > 85:
                status = "warning"
            if cpu_percent > 95 or memory.percent > 95:
                status = "critical"

            return {
                "status": status,
                "metrics": performance_metrics,
                "performance_grade": self._calculate_performance_grade(
                    performance_metrics
                ),
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_memory_usage(self) -> Dict[str, Any]:
        """Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï≤¥ÌÅ¨"""
        try:
            process = psutil.Process()
            memory_info = process.memory_info()
            system_memory = psutil.virtual_memory()

            memory_status = {
                "process_memory_mb": memory_info.rss / 1024 / 1024,
                "process_memory_percent": (memory_info.rss / system_memory.total) * 100,
                "system_memory_total_gb": system_memory.total / 1024 / 1024 / 1024,
                "system_memory_available_gb": system_memory.available
                / 1024
                / 1024
                / 1024,
                "system_memory_percent": system_memory.percent,
            }

            status = "ok"
            if memory_status["system_memory_percent"] > 80:
                status = "warning"
            if memory_status["system_memory_percent"] > 90:
                status = "critical"

            return {"status": status, "memory_status": memory_status}

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_disk_space(self) -> Dict[str, Any]:
        """ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ Ï≤¥ÌÅ¨"""
        try:
            disk_usage = psutil.disk_usage(".")

            disk_status = {
                "total_gb": disk_usage.total / 1024 / 1024 / 1024,
                "used_gb": disk_usage.used / 1024 / 1024 / 1024,
                "free_gb": disk_usage.free / 1024 / 1024 / 1024,
                "usage_percent": (disk_usage.used / disk_usage.total) * 100,
            }

            status = "ok"
            if disk_status["usage_percent"] > 80:
                status = "warning"
            if disk_status["usage_percent"] > 90:
                status = "critical"

            return {"status": status, "disk_status": disk_status}

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _check_import_health(self) -> Dict[str, Any]:
        """ÏûÑÌè¨Ìä∏ ÏÉÅÌÉú Ï≤¥ÌÅ¨"""
        try:
            critical_modules = [
                "src.analysis.pattern_analyzer",
                "src.models.ml.lightgbm_model",
                "src.models.dl.autoencoder_model",
                "src.core.recommendation_engine",
                "src.evaluation.backtester",
            ]

            import_status = {}
            failed_imports = []

            for module_name in critical_modules:
                try:
                    importlib.import_module(module_name)
                    import_status[module_name] = {"importable": True, "error": None}
                except Exception as e:
                    import_status[module_name] = {"importable": False, "error": str(e)}
                    failed_imports.append(module_name)

            status = "ok" if not failed_imports else "error"

            return {
                "status": status,
                "imports": import_status,
                "failed_imports": failed_imports,
                "success_rate": (len(critical_modules) - len(failed_imports))
                / len(critical_modules),
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _calculate_performance_grade(self, metrics: Dict[str, Any]) -> str:
        """ÏÑ±Îä• Îì±Í∏â Í≥ÑÏÇ∞"""
        try:
            cpu_score = 100 - metrics["cpu_usage_percent"]
            memory_score = 100 - metrics["memory_usage_percent"]
            speed_score = max(0, 100 - (metrics["cpu_test_time"] * 100))

            overall_score = (cpu_score + memory_score + speed_score) / 3

            if overall_score >= 80:
                return "A"
            elif overall_score >= 60:
                return "B"
            elif overall_score >= 40:
                return "C"
            else:
                return "D"

        except Exception:
            return "Unknown"

    def _assess_overall_health(self, diagnostics: Dict[str, Any]) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ Í±¥Í∞ï ÏÉÅÌÉú ÌèâÍ∞Ä"""
        try:
            status_counts = {"ok": 0, "warning": 0, "error": 0, "critical": 0}

            for diagnostic_name, diagnostic_result in diagnostics.items():
                status = diagnostic_result.get("status", "error")
                if status in status_counts:
                    status_counts[status] += 1
                else:
                    status_counts["error"] += 1

            total_checks = sum(status_counts.values())

            # Ï†ÑÏ≤¥ ÏÉÅÌÉú Í≤∞Ï†ï
            if status_counts["critical"] > 0:
                overall_status = "critical"
            elif status_counts["error"] > 0:
                overall_status = "error"
            elif status_counts["warning"] > total_checks * 0.3:
                overall_status = "warning"
            else:
                overall_status = "ok"

            health_score = (
                (
                    (
                        status_counts["ok"] * 100
                        + status_counts["warning"] * 70
                        + status_counts["error"] * 30
                        + status_counts["critical"] * 0
                    )
                    / total_checks
                )
                if total_checks > 0
                else 0
            )

            return {
                "status": overall_status,
                "health_score": health_score,
                "status_counts": status_counts,
                "total_checks": total_checks,
            }

        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _generate_recommendations(self, diagnostics: Dict[str, Any]) -> List[str]:
        """Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±"""
        recommendations = []

        try:
            # ÏùòÏ°¥ÏÑ± Î¨∏Ï†ú
            if diagnostics.get("dependencies", {}).get("status") != "ok":
                missing = diagnostics["dependencies"].get("missing_packages", [])
                if missing:
                    recommendations.append(f"ÎàÑÎùΩÎêú Ìå®ÌÇ§ÏßÄ ÏÑ§Ïπò: {', '.join(missing)}")

            # ÏÑ§Ï†ï Î¨∏Ï†ú
            if diagnostics.get("configuration", {}).get("status") != "ok":
                recommendations.append("ÏÑ§Ï†ï ÌååÏùºÏùÑ ÌôïÏù∏ÌïòÍ≥† ÏàòÏ†ïÌïòÏÑ∏Ïöî")

            # ÌååÏùº Íµ¨Ï°∞ Î¨∏Ï†ú
            file_struct = diagnostics.get("file_structure", {})
            if file_struct.get("status") != "ok":
                missing_dirs = file_struct.get("missing_directories", [])
                missing_files = file_struct.get("missing_files", [])
                if missing_dirs:
                    recommendations.append(
                        f"ÎàÑÎùΩÎêú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±: {', '.join(missing_dirs)}"
                    )
                if missing_files:
                    recommendations.append(
                        f"ÎàÑÎùΩÎêú ÌååÏùº ÌôïÏù∏: {', '.join(missing_files)}"
                    )

            # ÏÑ±Îä• Î¨∏Ï†ú
            performance = diagnostics.get("performance", {})
            if performance.get("status") in ["warning", "critical"]:
                metrics = performance.get("metrics", {})
                if metrics.get("cpu_usage_percent", 0) > 80:
                    recommendations.append(
                        "CPU ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. Ïã§Ìñâ Ï§ëÏù∏ ÌîÑÎ°úÏÑ∏Ïä§Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî"
                    )
                if metrics.get("memory_usage_percent", 0) > 80:
                    recommendations.append(
                        "Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. Î©îÎ™®Î¶¨ Ï†ïÎ¶¨Î•º Ïã§ÌñâÌïòÏÑ∏Ïöî"
                    )

            # Î©îÎ™®Î¶¨ Î¨∏Ï†ú
            memory = diagnostics.get("memory_usage", {})
            if memory.get("status") in ["warning", "critical"]:
                recommendations.append("Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôîÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî")

            # ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ Î¨∏Ï†ú
            disk = diagnostics.get("disk_space", {})
            if disk.get("status") in ["warning", "critical"]:
                recommendations.append(
                    "ÎîîÏä§ÌÅ¨ Í≥µÍ∞ÑÏùÑ ÌôïÎ≥¥ÌïòÏÑ∏Ïöî. Î∂àÌïÑÏöîÌïú ÌååÏùºÏùÑ ÏÇ≠Ï†úÌïòÏÑ∏Ïöî"
                )

            # ÏûÑÌè¨Ìä∏ Î¨∏Ï†ú
            imports = diagnostics.get("import_health", {})
            if imports.get("status") != "ok":
                failed = imports.get("failed_imports", [])
                if failed:
                    recommendations.append(
                        f"ÏûÑÌè¨Ìä∏ Ïã§Ìå® Î™®Îìà ÌôïÏù∏: {', '.join(failed)}"
                    )

            if not recommendations:
                recommendations.append("ÏãúÏä§ÌÖúÏù¥ Ï†ïÏÉÅ ÏÉÅÌÉúÏûÖÎãàÎã§")

        except Exception as e:
            recommendations.append(f"Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {e}")

        return recommendations

    def save_diagnostic_report(self, output_dir: str = "data/diagnostics") -> str:
        """ÏßÑÎã® Î≥¥Í≥†ÏÑú Ï†ÄÏû•"""
        try:
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)

            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = output_path / f"system_diagnostics_{timestamp}.json"

            with open(report_file, "w", encoding="utf-8") as f:
                json.dump(
                    self.diagnostic_results,
                    f,
                    ensure_ascii=False,
                    indent=2,
                    default=str,
                )

            self.logger.info(f"ÏßÑÎã® Î≥¥Í≥†ÏÑú Ï†ÄÏû•: {report_file}")
            return str(report_file)

        except Exception as e:
            self.logger.error(f"ÏßÑÎã® Î≥¥Í≥†ÏÑú Ï†ÄÏû• Ïã§Ìå®: {e}")
            return ""

    def get_health_summary(self) -> Dict[str, Any]:
        """Í±¥Í∞ï ÏÉÅÌÉú ÏöîÏïΩ"""
        if not self.diagnostic_results:
            return {"status": "not_diagnosed", "message": "ÏßÑÎã®Ïù¥ Ïã§ÌñâÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§"}

        overall_health = self.diagnostic_results.get("overall_health", {})
        recommendations = self.diagnostic_results.get("recommendations", [])

        return {
            "status": overall_health.get("status", "unknown"),
            "health_score": overall_health.get("health_score", 0),
            "total_checks": overall_health.get("total_checks", 0),
            "critical_issues": len(
                [r for r in recommendations if "critical" in r.lower()]
            ),
            "recommendations_count": len(recommendations),
            "last_check": self.diagnostic_results.get("timestamp"),
            "execution_time": self.diagnostic_results.get("execution_time", 0),
        }


# Ìé∏Ïùò Ìï®ÏàòÎì§
def run_system_diagnostics(config_path: Optional[str] = None) -> Dict[str, Any]:
    """ÏãúÏä§ÌÖú ÏßÑÎã® Ïã§Ìñâ"""
    diagnostics = SystemDiagnostics(config_path)
    return diagnostics.run_full_diagnostics()


def get_system_health_summary(config_path: Optional[str] = None) -> Dict[str, Any]:
    """ÏãúÏä§ÌÖú Í±¥Í∞ï ÏÉÅÌÉú ÏöîÏïΩ"""
    diagnostics = SystemDiagnostics(config_path)
    diagnostics.run_full_diagnostics()
    return diagnostics.get_health_summary()
